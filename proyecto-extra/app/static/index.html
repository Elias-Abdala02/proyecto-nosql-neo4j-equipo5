<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Proyecto Extra - Neo4J CRUD</title>
  <script src="https://unpkg.com/vis-network@9.1.2/standalone/umd/vis-network.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.5; }
    h1, h2 { margin-bottom: 0.2em; }
    .card { border: 1px solid #ddd; padding: 12px; margin-bottom: 12px; border-radius: 6px; }
    label { display: block; margin-top: 6px; }
    input, select, button { margin-top: 4px; padding: 6px; }
    pre { background: #f7f7f7; padding: 10px; max-height: 280px; overflow: auto; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .row .card { flex: 1 1 320px; }
    #graph { height: 480px; border: 1px solid #ddd; border-radius: 6px; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Proyecto Extra - Neo4J CRUD</h1>
  <p>UI mínima para probar las operaciones CRUD sobre Neo4J. Usa los mismos endpoints expuestos por la API FastAPI.</p>

  <div class="row">
    <div class="card">
      <h2>Sembrar datos (seed)</h2>
      <button onclick="seed()">Ejecutar /seed</button>
    </div>
    <div class="card">
      <h2>Healthcheck</h2>
      <button onclick="health()">Ping</button>
    </div>
    <div class="card">
      <h2>Top productos</h2>
      <label>Límite</label>
      <input type="number" id="limit" value="5" min="1" max="20">
      <button onclick="topProducts()">Consultar</button>
    </div>
  </div>

  <div class="row">
    <div class="card">
      <h2>Crear cliente</h2>
      <label>ID</label><input id="c-id" type="number" value="9999">
      <label>Edad</label><input id="c-age" type="number" value="28">
      <label>Género</label><input id="c-gender" value="Female">
      <label>Ubicación</label><input id="c-location" value="California">
      <label>Suscripción</label><input id="c-sub" value="Yes">
      <label>Compras previas</label><input id="c-prev" type="number" value="5">
      <label>Frecuencia</label><input id="c-freq" value="Monthly">
      <button onclick="createCustomer()">Crear / MERGE</button>
    </div>
    <div class="card">
      <h2>Actualizar edad</h2>
      <label>ID Cliente</label><input id="u-id" type="number" value="9999">
      <label>Nueva edad</label><input id="u-age" type="number" value="30">
      <button onclick="updateAge()">Actualizar</button>
    </div>
    <div class="card">
      <h2>Eliminar cliente</h2>
      <label>ID Cliente</label><input id="d-id" type="number" value="9999">
      <button onclick="deleteCustomer()">Eliminar</button>
    </div>
  </div>

  <div class="card">
    <h2>Salida</h2>
    <pre id="output">Listo para usar.</pre>
  </div>

  <div class="card">
    <h2>Visualizar subgrafo</h2>
    <label>Centro</label>
    <select id="g-center-type">
      <option value="category">Categoría</option>
      <option value="product">Producto</option>
      <option value="customer">Cliente</option>
    </select>
    <label>Valor (nombre o ID)</label>
    <select id="g-center-value"></select>
    <label>Profundidad (niveles)</label>
    <select id="g-depth">
      <option value="1">1</option>
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select>
    <label>Límite de resultados</label>
    <input type="number" id="g-limit" value="30" min="5" max="200">
    <button onclick="loadGraph()">Cargar subgrafo</button>
    <button onclick="loadFullGraph()" style="background-color: #2196F3; color: white;">Ver grafo completo</button>
    <div id="graph"></div>
  </div>

  <div class="card">
    <h2>Detalle de nodo</h2>
    <pre id="node-info">Haz clic en un nodo para ver sus propiedades.</pre>
  </div>

  <script>
    const out = document.getElementById('output');
    const nodeInfo = document.getElementById('node-info');
    const api = (path) => `http://localhost:8000${path}`;
    const centerTypeSel = document.getElementById('g-center-type');
    const centerValueSel = document.getElementById('g-center-value');
    const depthSel = document.getElementById('g-depth');

    async function seed() {
      await call('POST', '/seed');
    }
    async function health() { await call('GET', '/health'); }
    async function topProducts() {
      const limit = document.getElementById('limit').value || 5;
      await call('GET', `/read/top-products?limit=${limit}`);
    }
    async function createCustomer() {
      const payload = {
        customerId: Number(document.getElementById('c-id').value),
        age: Number(document.getElementById('c-age').value),
        gender: document.getElementById('c-gender').value,
        location: document.getElementById('c-location').value,
        subscriptionStatus: document.getElementById('c-sub').value,
        previousPurchases: Number(document.getElementById('c-prev').value),
        frequency: document.getElementById('c-freq').value
      };
      await call('POST', '/customers', payload);
    }
    async function updateAge() {
      const id = document.getElementById('u-id').value;
      const age = document.getElementById('u-age').value;
      await call('PATCH', `/update/customer-age/${id}?age=${age}`);
    }
    async function deleteCustomer() {
      const id = document.getElementById('d-id').value;
      await call('DELETE', `/delete/customer/${id}`);
    }

    async function call(method, path, body) {
      try {
        const res = await fetch(api(path), {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: body ? JSON.stringify(body) : null
        });
        const data = await res.json();
        out.textContent = JSON.stringify(data, null, 2);
        return data;
      } catch (err) {
        out.textContent = `Error: ${err}`;
      }
    }
    async function callRaw(method, path, body) {
      try {
        const res = await fetch(api(path), {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: body ? JSON.stringify(body) : null
        });
        if (!res.ok) {
          out.textContent = `Error HTTP: ${res.status} - ${res.statusText}`;
          return null;
        }
        return await res.json();
      } catch (err) {
        out.textContent = `Error de red: ${err.message}`;
        return null;
      }
    }
    async function loadGraph() {
      try {
        const limit = document.getElementById('g-limit').value || 30;
        const depth = document.getElementById('g-depth').value || 2;
        const centerType = centerTypeSel.value;
        const centerValue = centerValueSel.value || 'Clothing';
        
        out.textContent = `Cargando subgrafo (tipo: ${centerType}, valor: ${centerValue}, profundidad: ${depth}, límite: ${limit})...`;
        
        const url = `/graph/sample?limit=${limit}&depth=${depth}&centerType=${centerType}&centerValue=${encodeURIComponent(centerValue)}`;
        console.log('Llamando a:', url);
        
        const data = await callRaw('GET', url);
        
        if (!data) {
          out.textContent = 'Error: No se recibió respuesta del servidor.';
          return;
        }
        
        if (!data.nodes) {
          out.textContent = `Error: Respuesta inválida: ${JSON.stringify(data)}`;
          return;
        }
        
        console.log('Datos recibidos:', data.nodes.length, 'nodos,', data.links.length, 'links');
        
        const container = document.getElementById('graph');
        const options = {
          layout: { 
            improvedLayout: true,
            randomSeed: 42
          },
          nodes: { 
            shape: 'dot', 
            size: 16,
            font: { size: 12 },
            borderWidth: 2,
            shadow: true
          },
          edges: { 
            arrows: 'to', 
            smooth: { 
              type: 'continuous',
              forceDirection: 'none'
            }, 
            width: 1,
            color: { inherit: 'from' }
          },
          physics: {
            enabled: true,
            solver: 'forceAtlas2Based',
            forceAtlas2Based: {
              gravitationalConstant: -100,
              centralGravity: 0.015,
              springLength: 180,
              springConstant: 0.03,
              damping: 0.5,
              avoidOverlap: 0.8
            },
            stabilization: {
              enabled: true,
              iterations: 400,
              updateInterval: 50,
              fit: true
            },
            adaptiveTimestep: true
          },
          interaction: { 
            hover: true,
            navigationButtons: true,
            keyboard: true,
            zoomView: true,
            dragView: true
          }
        };
        
        const nodesDS = new vis.DataSet(data.nodes);
        const edgesDS = new vis.DataSet(data.links);
        const network = new vis.Network(container, { nodes: nodesDS, edges: edgesDS }, options);
        
        // Detener física después de estabilizar
        network.once('stabilizationIterationsDone', function() {
          network.setOptions({ physics: { enabled: false } });
          network.fit();
        });
        
        network.on('click', (params) => {
          if (params.nodes.length) {
            const nodeId = params.nodes[0];
            const node = nodesDS.get(nodeId);
            nodeInfo.textContent = JSON.stringify(node, null, 2);
          } else {
            nodeInfo.textContent = 'Haz clic en un nodo para ver sus propiedades.';
          }
        });
        
        out.textContent = `Subgrafo cargado (${data.nodes.length} nodos, ${data.links.length} relaciones).`;
      } catch (error) {
        out.textContent = `Error inesperado: ${error.message}`;
        console.error('Error en loadGraph:', error);
      }
    }

    async function loadFullGraph() {
      const limit = document.getElementById('g-limit').value || 500;
      out.textContent = 'Cargando grafo completo...';
      const data = await callRaw('GET', `/graph/full?limit=${limit}`);
      if (!data || !data.nodes) {
        out.textContent = 'Error al cargar el grafo completo.';
        return;
      }
      const container = document.getElementById('graph');
      const options = {
        layout: { 
          improvedLayout: true,
          randomSeed: 42
        },
        nodes: { 
          shape: 'dot', 
          size: 16,
          font: { size: 12 },
          borderWidth: 2,
          shadow: true
        },
        edges: { 
          arrows: 'to', 
          smooth: { 
            type: 'continuous',
            forceDirection: 'none'
          }, 
          width: 1,
          color: { inherit: 'from' }
        },
        physics: {
          enabled: true,
          solver: 'forceAtlas2Based',
          forceAtlas2Based: {
            gravitationalConstant: -150,
            centralGravity: 0.02,
            springLength: 200,
            springConstant: 0.02,
            damping: 0.5,
            avoidOverlap: 1
          },
          stabilization: {
            enabled: true,
            iterations: 500,
            updateInterval: 50,
            fit: true
          },
          adaptiveTimestep: true
        },
        interaction: { 
          hover: true,
          navigationButtons: true,
          keyboard: true,
          zoomView: true,
          dragView: true
        }
      };
      const nodesDS = new vis.DataSet(data.nodes);
      const edgesDS = new vis.DataSet(data.links);
      const network = new vis.Network(container, { nodes: nodesDS, edges: edgesDS }, options);
      
      // Detener física después de estabilizar
      network.once('stabilizationIterationsDone', function() {
        network.setOptions({ physics: { enabled: false } });
        network.fit();
      });
      network.on('click', (params) => {
        if (params.nodes.length) {
          const nodeId = params.nodes[0];
          const node = nodesDS.get(nodeId);
          nodeInfo.textContent = JSON.stringify(node, null, 2);
        } else {
          nodeInfo.textContent = 'Haz clic en un nodo para ver sus propiedades.';
        }
      });
      out.textContent = `Grafo completo cargado (${data.nodes.length} nodos, ${data.links.length} relaciones).`;
    }

    async function populateValues() {
      const type = centerTypeSel.value;
      const res = await callRaw('GET', `/graph/options?type=${type}`);
      if (!res || !res.values) return;
      centerValueSel.innerHTML = '';
      res.values.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        centerValueSel.appendChild(opt);
      });
      // ajustar profundidad sugerida (categoría y producto usualmente 2-3, cliente 2)
      if (type === 'customer') {
        depthSel.value = '2';
      } else {
        depthSel.value = '3';
      }
    }

    // Inicializar opciones al cargar
    centerTypeSel.addEventListener('change', populateValues);
    window.addEventListener('load', populateValues);
  </script>
</body>
</html>
